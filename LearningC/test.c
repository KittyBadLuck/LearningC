#include <stdio.h>#include <stdlib.h>#include <time.h>typedef struct Node {    int data;    struct Node* next;    struct Node* prev;} Node;Node* create_node(int data) {    Node* new_node = (Node*)malloc(sizeof(Node));    if (new_node == NULL) {        printf("Memory allocation failed\n");        exit(1);    }    new_node->data = data;    new_node->next = NULL;    new_node->prev = NULL;    return new_node;}void append(Node** head, int data) {    Node* new_node = create_node(data);    Node* last = *head;    if (*head == NULL) {        *head = new_node;        return;    }    while (last->next != NULL) {        last = last->next;    }    last->next = new_node;    new_node->prev = last;}void print_list(Node* node) {    while (node != NULL) {        printf("%d ", node->data);        node = node->next;    }    printf("\n");}void free_list(Node* head) {    Node* tmp;    while (head != NULL) {        tmp = head;        head = head->next;        free(tmp);    }}void remove_duplicates_sorted(Node* head) {    Node* current = head;    while (current != NULL && current->next != NULL) {        if (current->data == current->next->data) {            Node* temp = current->next;            current->next = temp->next;            if (temp->next != NULL) {                temp->next->prev = current;            }            free(temp);        } else {            current = current->next;        }    }}void remove_duplicates_unsorted(Node* head) {    Node* current = head;    while (current != NULL && current->next != NULL) {        Node* runner = current->next;        while (runner != NULL) {            if (runner->data == current->data) {                Node* temp = runner;                if (runner->prev != NULL) {                    runner->prev->next = runner->next;                }                if (runner->next != NULL) {                    runner->next->prev = runner->prev;                }                runner = runner->next;                free(temp);            } else {                runner = runner->next;            }        }        current = current->next;    }}int compare(const void* a, const void* b) {    return (*(Node**)a)->data - (*(Node**)b)->data;}void sort_list(Node** head) {    if (*head == NULL) {        return;    }    Node* current = *head;    int length = 0;    while (current != NULL) {        length++;        current = current->next;    }    Node** array = (Node**)malloc(length * sizeof(Node*));    current = *head;    for (int i = 0; i < length; i++) {        array[i] = current;        current = current->next;    }    qsort(array, length, sizeof(Node*), compare);    for (int i = 0; i < length - 1; i++) {        array[i]->next = array[i + 1];        array[i + 1]->prev = array[i];    }    array[length - 1]->next = NULL;    array[0]->prev = NULL;    *head = array[0];    free(array);}int main() {    srand(time(NULL));    Node* head = NULL;    // Initialize the list with 200 random integers between 0 and 49    for (int i = 0; i < 200; i++) {        append(&head, rand() % 50);    }    printf("Original List:\n");    print_list(head);    // Method 1: Sort the list and remove adjacent duplicates    sort_list(&head);    printf("\nSorted List:\n");    print_list(head);    remove_duplicates_sorted(head);    printf("\nList after removing duplicates (sorted method):\n");    print_list(head);    // Free the list and recreate it for the second method    free_list(head);    head = NULL;    for (int i = 0; i < 200; i++) {        append(&head, rand() % 50);    }    printf("\nOriginal List (for unsorted method):\n");    print_list(head);    // Method 2: Remove duplicates without sorting    remove_duplicates_unsorted(head);    printf("\nList after removing duplicates (unsorted method):\n");    print_list(head);    free_list(head);    return 0;}